use sodiumoxide::crypto;
use std::{convert::TryInto, vec::Vec};

/// Specifies an interface for generating secure
/// cryptographic keypairs.
pub trait KeypairGenerator {
    fn create() -> ([u8; 32], [u8; 32]);
}

/// Implements the KeypairGenerator trait using the
/// sodiumoxide trait to provide the backing crypto
/// Sodiumoxide is simply an FFI into the well-known
/// libsodium library.
/// The keys generated by libsodium are ECDSA keys
/// using a combination of Curve25519, Salsa20, and
/// Poly1305.
/// For more information on the crypto, see:
/// http://nacl.cr.yp.to/valid.html
pub struct SodiumOxideKeypairGenerator {}

impl SodiumOxideKeypairGenerator {
    /// Calls sodiumoxide's init function.
    /// According to libsodium's documentation, it's safe to call this
    /// function multiple times:
    /// https://libsodium.gitbook.io/doc/usage
    pub fn init() -> Result<(), ()> {
        sodiumoxide::init()
    }
}

impl KeypairGenerator for SodiumOxideKeypairGenerator {
    /// Generates an ECDSA keypair using a combination of Curve25519, Salsa20,
    /// and Poly1305.
    fn create() -> ([u8; 32], [u8; 32]) {
        let (pk, sk) = crypto::box_::gen_keypair();
        // Discussion about iter->fized-size array conversion here:
        // https://github.com/rust-lang/rust/issues/81615
        let pk_arr: [u8; 32] = pk
            .as_ref()
            .iter()
            .copied()
            .collect::<Vec<u8>>()
            .try_into()
            .unwrap();
        let sk_arr: [u8; 32] = sk
            .as_ref()
            .iter()
            .copied()
            .collect::<Vec<u8>>()
            .try_into()
            .unwrap();
        (pk_arr, sk_arr)
    }
}
